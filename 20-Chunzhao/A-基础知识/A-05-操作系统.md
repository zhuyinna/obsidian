# 硬件结构

## 结构
### CPU cache
CPU Cache 用的是一种叫 **SRAM（_Static Random-Access_ Memory，静态随机存储器）** 的芯片。

SRAM 之所以叫「静态」存储器，是因为只要有电，数据就可以保持存在，而一旦断电，数据就会丢失了。

在 SRAM 里面，一个 bit 的数据，通常需要 6 个晶体管，所以 SRAM 的存储密度不高，同样的物理空间下，能存储的数据是有限的，不过也因为 SRAM 的电路简单，所以访问速度非常快。

下图注意：L3cache是多核心共享，而L1和L2是cpu核心独有的。
![[Pasted image 20240402112539.png|375]]
![[Pasted image 20240402113649.png|400]]

```ad-question
64 位相比 32 位 CPU 的优势在哪吗？64 位 CPU 的计算性能一定比 32 位 CPU 高很多吗？
```
- 64位的cpu一次能够对超过32位的数字进行运算，而32位的cpu如果运算的话需要分步，但是大部分时候不会用到那么高位的数字，所以只有在运算大数字的时候64位的优势才会体现出来。
- 64位：更大的物理寻址空间，2^48, 而32位：2^32 - 4G
```ad-question
你知道软件的 32 位和 64 位之间的区别吗？再来 32 位的操作系统可以运行在 64 位的电脑上吗？64 位的操作系统可以运行在 32 位的电脑上吗？如果不行，原因是什么？
```
32位和64位软件实际上代表的是不同指令是32还是64。
32软件要运行在64机器上，需要兼容机制。而64软件不能运行在32机器上。
>硬件的32位指的是CPU位宽，软件的32位指的是指令位宽。

### 内存
内存用的芯片和 CPU Cache 有所不同，它使用的是一种叫作 **DRAM （_Dynamic Random Access Memory_，动态随机存取存储器）** 的芯片。

### SSD/HDD
SSD（_Solid-state disk_） 就是我们常说的固体硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都会丢失。内存的读写速度比 SSD 大概快 `10~1000` 倍。

## 缓存引发的问题

### 写入方式
写直达 writethrough
写回 writeback：如果缓存命中，则标记为脏数据，暂时不写回内存。如果缓存不命中，需要和内存进行替换，如果为脏数据则写回，并读取新数据。

### 缓存不一致

因为写回没有立即修改内存，这时候其他cpu核读取内存会出现不一致。解决方法：
- 写传播
- 串行化（引入锁的概念）
基于总线嗅探机制的 MESI 协议，就满足上面了这两点，因此它是保障缓存一致性的协议。
MESI 协议，是已修改、独占、共享、已失效这四个状态的英文缩写的组合。整个 MSI 状态的变更，则是根据来自本地 CPU 核心的请求，或者来自其他 CPU 核心通过总线传输过来的请求，从而构成一个流动的状态机。另外，对于在「已修改」或者「独占」状态的 Cache Line，修改更新其数据不需要发送广播给其他 CPU 核心。


### 伪共享
多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为**伪共享（_False Sharing_）**

**解决方式**：

1. 内核层面——cacheline 大小字节对齐
   在 Linux 内核中存在 `__cacheline_aligned_in_smp` 宏定义，是用于解决伪共享的问题。

对于多个线程共享的热点数据，即经常会修改的数据，应该避免这些数据刚好在同一个 Cache Line 中，否则就会出现为伪共享的问题。
- 如果在多核（MP）系统里，该宏定义是 `__cacheline_aligned`，也就是 Cache Line 的大小；
- 而如果在单核系统里，该宏定义是空的；
![[Pasted image 20240402124624.png|475]]
具体用法，对于一个struct结构：
![[Pasted image 20240402124855.png|475]]

2. 应用层面：字节填充
   有一个 Java 并发框架 Disruptor 使用「字节填充 + 继承」的方式，来避免伪共享的问题。

根据 JVM 对象继承关系中父类成员和子类成员，内存地址是连续排列布局的，因此 RingBufferPad 中的 7 个 long 类型数据作为 Cache Line **前置填充**，而 RingBuffer 中的 7 个 long 类型数据则作为 Cache Line **后置填充**，这 14 个 long 变量没有任何实际用途，更不会对它们进行读写操作。
U是其他无关变量，V是高频访问的可能引发伪共享的变量，P是填充变量

![[Pasted image 20240402130005.png]]



## cache的映射方式
#todo

## CPU执行任务

每个进程/线程都是一个tast struct

![[Pasted image 20240402130331.png|475]]


根据调度类分为：
- deadline：对应dl_rq
- realtime：先来先调度，对应rt_rq
- fair：普通任务，公平的分时间片，对应cfs_rq
从上到下的优先级
![[Pasted image 20240402131756.png]]

## 软中断
linux中断分为两部分：
- 硬中断：硬件触发，短且快
- 软中断：内核线程触发，用来异步处理上半部分未完成的
软中断不止处理这个，还可以用于网络收发、定时、调度、RCU锁等（TODO：查询）。

> Linux 中的软中断包括网络收发、定时、调度、RCU 锁等各种类型，可以通过查看 /proc/softirqs 来观察软中断的累计中断次数情况，如果要实时查看中断次数的变化率，可以使用 watch -d cat /proc/softirqs 命令。
每一个 CPU 都有各自的软中断内核线程，我们还可以用 ps 命令来查看内核线程，一般名字在中括号里面到，都认为是内核线程。
如果在 top 命令发现，CPU 在软中断上的使用率比较高，而且 CPU 使用率最高的进程也是软中断 ksoftirqd 的时候，这种一般可以认为系统的开销被软中断占据了。
这时我们就可以分析是哪种软中断类型导致的，一般来说都是因为网络接收软中断导致的，如果是的话，可以用 sar 命令查看是哪个网卡的有大量的网络包接收，再用 tcpdump 抓网络包，做进一步分析该网络包的源头是不是非法地址，如果是就需要考虑防火墙增加规则，如果不是，则考虑硬件升级等。

## 补码
**补码就是把正数的二进制全部取反再加 1**

我们二进制只能精准表达 2 除尽的数字 1/2, 1/4, 1/8，但是对于 0.1(1/10) 和 0.2(1/5)，在二进制中都无法精准表示时，需要根据精度舍入

所以0.1+0.2不等于0.3，只能近似






#Todo 
redis缓存？![[Pasted image 20240402113945.png|275]]



# 操作系统结构
