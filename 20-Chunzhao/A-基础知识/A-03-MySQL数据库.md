


# 基本教程@菜鸟教程
冗余，主键，外键，复合键，**索引**
## 索引
### 分类
1. 普通索引
   CREATE INDEX index_name ON TABLE (column1)；
   ALTER TABLE ADD INDEX index_name  (column)；
   CREATE TABLE table_name(....., INDEX idx_age (age));
   删除 DROP INDEX index_name ON table_name; 
   ALTER TABLE table_name DROP INDEX index_name;
2. 唯一索引
   索引中的值是唯一的，不允许有重复值
   CREATE UNIQUE INDEX index_name；
   ALTER table mytable 
	ADD CONSTRAINT unique_constraint_name UNIQUE (column1, column2, ...);
   用法基本和普通索引相同
3. 聚焦索引
   ```ad-question
   是否就是 第一个唯一索引？
   ```

### 其他概念
1. **索引覆盖**
   只需要在一颗索引树就能获取SQL所需的所有列数据，无需回表，速度更快。
2. 怎么实现索引覆盖？
   - 将被查询的字段，建立到联合索引里去
     例如单列索引(name)升级为联合索引(name, sex)
     能够命中name索引，索引叶子节点存储了主键id，通过name的索引树即可获取id和name，无需回表，符合索引覆盖，效率较高。
     画外音，Extra：Using index。
3. 索引下推优化
	   简称ICP优化，取出索引的同时，判断是否可以进行where条件过滤再进行索引查询。——减少回表次数。当你的查询语句的执行计划里，出现了 Extra 为 `Using index condition`，那么说明使用了索引下推的优化。
## 事务
InnoDB存储引擎才有。
特点：原子性、一致性、隔离性、持久性。
BEGIN或者START TRANSACTION
ROLLBACK
COMMIT

## 回表

主键索引的查询：只需要搜索id这颗B+树，就能确定记录。
基于非主键索引的查询：例如对普通索引进行，先搜索索引树，得到主键ID的值，再去ID索引树搜索一次。
明显，主键查询效率更高。 

*结论*
使用聚焦索引（主键或第一个唯一索引）就不会回标，普通索引就会回表

# 基础篇@小林coding
## 执行查询语句

<img src=https://s2.loli.net/2024/03/31/IxiAdk5Ys2LpQgE.png width='100%'>

执行语句的流程
- 连接器
	- 建立连接，管理连接，校验用户身份
	- 基于TCP协议——三次握手四次挥手
	- 长连接 || 短连接
- 查询缓存
	- 比较鸡肋
- 解析SQL
	- 词法分析：关键字，非关键字
	- 语法分析：是否满足MySQL语法，但不会检查表/字段是否存在
- 执行SQL
	- prepare阶段：检查是否存在；替换\*为所有列
	- optimize优化器 ：确定执行方案——例如表里面有多个索引，会选择代价小的索引
	- execute执行器：

## 存储
1. 总体结构
![[Pasted image 20240331212739.png|400]]

2. 行记录存储
   ![[Pasted image 20240331213342.png|550]]
   变长字段长度列表是逆序存储的：记录头信息指向的是下一个记录头信息和真实数据之间的位置，左读就是头信息，右读是数据。可以同时在一个CPU cacheline里，提高CPU cache命中率。
   **NULL值记录信息**：NULL为1，非NULL为0，高位补0来满足一个字节长度，注意也是逆序。   ![[Pasted image 20240331213722.png|675]]

3. 主键索引
   如果使用的是 MyISAM 存储引擎，B+ 树索引的叶子节点保存数据的物理地址，即用户数据的指针，如下图：
   <img src=https://s2.loli.net/2024/03/31/HYqdLfc1SzuINE7.png width='100%'>
   
   如果使用的是 InnoDB 存储引擎， B+ 树索引的叶子节点保存数据本身，如下图所示：
   <img src=https://s2.loli.net/2024/03/31/7mHDwaBXg1izdQ6.png width='100%'>
   
# 索引篇@小林coding

## TL;DR
<img src=https://s2.loli.net/2024/03/31/ao3npGMCZghXEQO.png width='100%'>
<img src=https://s2.loli.net/2024/03/31/QWpIUwAG4y9EPLn.png width='100%'>


### 联合索引

1. 联合索引：最左匹配原则

 <img src=https://s2.loli.net/2024/03/31/Li4aNQT3cJVDdAl.png width='100%'>
 
1. 联合索引：范围查询
   联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。**也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引**。

### 索引失效

1. 当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效。
2. 用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。（原因：索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了）
3. 查询条件中对索引进行表达式计算
4. 对索引隐式类型转换
   > mysql会将字符串转为数字，如果需要比较的类型不同，如果转换部分是在key上，则导致索引失效。如果转换部分在value上，则还是走索引扫描。
5. 联合索引非最左匹配
6. where子句的or：如果or前是索引列，or之后不是



# 事务篇@小林coding
## 并发事务问题

### 脏读
**如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。**
### 不可重复读
**在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。**

### 幻读
**在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。**

## 解决方法
- **读未提交（_read uncommitted_）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读提交（_read committed_）**，指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读（_repeatable read_）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
- **串行化（_serializable_ ）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

<img src=https://s2.loli.net/2024/03/31/Krt7DGBlhFsw9Li.png width='100%'>
#Todo 

# 锁篇@小林coding

![[Pasted image 20240331234626.png|425]]

## MySQL 加锁

![[Pasted image 20240401114813.png]]

![[Pasted image 20240401114817.png]]

## 死锁
死锁的关键在于：2+ 的 session 加锁的顺序不一致。
那么对应的解决死锁问题的关键就是：让不同的 session 加锁有次序。
### 表锁死锁
- 用户A访问表A（锁住了表A），然后又访问表B；另一个用户B访问表B（锁住了表B），然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。
- 调整的程序的逻辑
### 行锁死锁
1. 事务中执行了一条没有索引条件的查询，引发全表扫描，把行级锁上升为全表记录锁定（等价于表锁），多个这样的事务执行后，就很容易产生死锁和阻塞，最终应用系统会越来越慢，发生阻塞或死锁。解决： SQL 语句中不要使用太复杂的关联多表的查询；使用 explain “执行计划"对 SQL 语句进行分析，对于有全表扫描和全表锁定的 SQL 语句，建立相应的索引进行优化。
   *所以在线上千万不要执行没有带索引条件的 update 语句，不然会造成业务停滞。*
2. 两个事务分别想拿到对方持有的锁，互相等待，于是产生死锁。解决：在同一个事务中，尽可能做到一次锁定所需要的所有资源；按照 id 对资源排序，然后按顺序进行处理
### 共享锁转为排他锁
- 事务A 查询一条纪录，然后更新该条纪录；此时事务B 也更新该条纪录，这时事务B 的排他锁由于事务A 有共享锁，必须等A 释放共享锁后才可以获取，只能排队等待。事务A 再执行更新操作时，此处发生死锁，因为事务A 需要排他锁来做更新操作。但是，无法授予该锁请求，因为事务B 已经有一个排他锁请求，并且正在等待事务A 释放其共享锁
- 对于按钮等控件，点击立刻失效，不让用户`重复点击`，避免引发同时对同一条记录多次操作；乐观锁：乐观锁机制`避免了长事务`中的数据库加锁开销，大大提升了大并发量下的系统性能。需要注意的是，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。

### 举例
间隙锁和插入意向锁互斥，产生死锁：

两个事务即使生成的间隙锁的范围是一样的，也不会发生冲突，因为间隙锁目的是为了防止其他事务插入数据，因此间隙锁与间隙锁之间是相互兼容的。

在执行插入语句时，如果插入的记录在其他事务持有间隙锁范围内，插入语句就会被阻塞，因为插入语句在碰到间隙锁时，会生成一个插入意向锁，然后插入意向锁和间隙锁之间是互斥的关系。

如果两个事务分别向对方持有的间隙锁范围内插入一条记录，而插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：**互斥、占有且等待、不可强占用、循环等待**，因此发生了死锁。

# TODO：问题汇总
#todo
1. sql，mysq区别
2. MVCC实现