![[Pasted image 20240330113224.png]]


# TCP篇

```ad-question
SYN 报文什么时候情况下会被丢弃
```
情况1：开启 tcp_tw_recycle 参数，并且在 NAT 环境下，造成 SYN 报文被丢弃
	如果同时开启了recycle 和 timestamps 选项，则会开启一种称之为「 per-host 的 PAWS 机制」。PAWs机制会自动丢弃满足序列、但是时间戳更小的SYN包。 PAWS要求双方维护最近的时间戳，如果收到的包中时间戳不是最新的，丢弃。本质原因：per-host 的 PAWS 机制是对端IP做检查，而不是IP+端口四元组做检查，而客户端环境的每一台机器通过NAT网关都是相同的IP地址（对于服务端来说）。
情况2：TCP 两个队列满了（半连接队列和全连接队列），造成 SYN 报文被丢弃
- 情况2.1 ：半连接满了
	- 解决：开启syncookie功能，满了的情况下，会生成cookie，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功；增大半连接队列；减少ACK+SYN重传次数。
- 情况2.2：全连接满了
	- 解决：调大队列；检查为什么accept()不及时。
```ad-question
TCP 连接，一端断电和进程崩溃有什么区别？
```
1. 客户端断电，服务端感知不到：
	1. 如果有数据发送，收不到数据报文的响应报文，超时重传达到阈值后，断开TCP连接
	2. 没有数据发送，看服务端是否开启keepalive机制
		1. 开启：开始计时，超时断开
		2. 未开启：一直处于established状态
2. 进程崩溃：内核会发送FIN报文，四次挥手

```ad-question
拔掉网线后， 原本的 TCP 连接还存在吗？
```
关键：拔掉之后是否有数据传输，以及是否有keepalive机制
```ad-question
tcp_tw_reuse 为什么默认是关闭的？
```
问题可以转化为：WAIT_TIME过短会有什么问题
tcp_tw_reuse 的作用是让客户端快速复用处于 TIME_WAIT 状态的端口，相当于跳过了 TIME_WAIT 状态，这可能会出现这样的两个问题：
- 历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 检查到即使 RST 是过期的，也不会丢弃。
- 如果第四次挥手的 ACK 报文丢失了，有可能被动关闭连接的一方不能被正常的关闭;
```ad-question
HTTPS 中 TLS 和 TCP 能同时握手吗
```
HTTPS 是先进行 TCP 三次握手，再进行 TLSv1.2 四次握手。
HTTPS 中的 TLS 握手过程可以同时进行三次握手，前提条件：
- **客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3**
- **客户端和服务端已经完成过一次通信**

```ad-question
TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？
```
1. HTTP 的 Keep-Alive
HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。
在 HTTP 1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的包头中添加：
`Connection: Keep-Alive`
然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：
`Connection: Keep-Alive`
**从 HTTP 1.1 开始， 就默认是开启了 Keep-Alive**，如果要关闭 Keep-Alive，需要在 HTTP 请求的包头里添加：
`Connection: close`
HTTP 长连接不仅仅减少了 TCP 连接资源的开销，而且这给 **HTTP 流水线**技术提供了可实现的基础。
流水线：，是**客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应**，可以减少整体的响应时间。

2. TCP 的 Keepalive 
TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。

```ad-question
如何基于 UDP 协议实现可靠传输？
```
![[Pasted image 20240401160226.png]]
具体剖析：
1. packetheader

![[Pasted image 20240401160237.png]]

Short Packet Header 中的 `Packet Number` 是每个报文独一无二的编号，它是**严格递增**的。
- - 可以更加精确计算 RTT，没有 TCP 重传的歧义性问题；
- - 可以支持乱序确认，因为丢包重传将当前窗口阻塞在原地，而 TCP 必须是顺序确认的，丢包时会导致窗口不滑动；

2. frameheader

![[Pasted image 20240401160506.png|325]]
内部：所以引入 Frame Header 这一层，**通过 Stream ID + Offset 字段信息实现数据的有序性**，通过比较两个数据包的 Stream ID 与 Stream Offset ，如果都是一致，就说明这两个数据包的内容一致。

总的来说，**QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以支持乱序确认而不影响数据包的正确组装**，摆脱了TCP 必须按顺序确认应答 ACK 的限制，解决了 TCP 因某个数据包重传而阻塞后续所有待发送数据包的问题。

**队头阻塞**
 **HTTP/2 多个 Stream 请求都是在一条 TCP 连接上传输，这意味着多个 Stream 共用同一个 TCP 滑动窗口**， 数据丢失，滑动窗口无法移动，此时会阻塞住所有的HTTP请求。
 QUIC改进方法： **给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口**

**流量控制**
- **Stream 级别的流量控制**：Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。
- **Connection 流量控制**：限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量。

**拥塞控制**
QUIC 协议当前默认使用了 TCP 的 Cubic 拥塞控制算法（我们熟知的慢开始、拥塞避免、快重传、快恢复策略），同时也支持 CubicBytes、Reno、RenoBytes、BBR、PCC 等拥塞控制算法，相当于将 TCP 的拥塞控制算法照搬过来了。QUIC 是处于应用层的，应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。

**连接迁移**
QUIC 协议没有用四元组的方式来“绑定”连接，而是通过**连接 ID**来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了**连接迁移**的功能。

```ad-question
TCP 和 UDP 可以使用同一个端口吗
```
有点难，具体还要再学习一下
[4.18 TCP 和 UDP 可以使用同一个端口吗？ | 小林coding](https://xiaolincoding.com/network/3_tcp/port.html#tcp-%E5%92%8C-udp-%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E7%BB%91%E5%AE%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%90%97)

```ad-question
服务端没有listen，客户端发起SYN，会发生什么？
```
**服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文**
```ad-question
没有listen能否建立TCP连接？没有accept能否实现TCP连接？
```
1. 能，自连接，或者两个客户端同时发送TCP握手申请。具体：
   **每一个**`socket`执行`listen`时，内核都会自动创建一个半连接队列和全连接队列。*所以形成连接，需要有个地方存放着，方便握手的时候能根据IP端口等信息找到socket信息。*
   （半连接——哈希表，全连接——链表）。全队列满了， 再来第三次握手会丢弃。半队列满了，设置`tcp_syncookies`，绕开半连接队列。- 客户端没有半连接队列和全连接队列，但有一个**全局hash**，可以通过它实现自连接或TCP同时打开。
1.  `accept方法`只是为了从全连接队列中拿出一条连接，本身跟三次握手几乎**毫无关系**。

```ad-question
TCP的seq号和ACK号是如何变化的
```
- **公式一：序列号 = 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。**
- **公式二：确认号 = 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。**



# IP篇