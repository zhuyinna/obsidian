#### 23、虚函数相关（虚函数表，虚函数指针），虚函数的实现原理

⾸先我们来说⼀下，   C++中多态的表象，在基类的函数前加上virtual 关键字，在派生类中重写该函数，运⾏时将会根据对象的实际类型来调⽤相应的函数。如果对象类型是派⽣类，就调⽤派⽣类的函数，如果是基类，就调⽤基类的函数。

实际上，当⼀个类中包含虚函数时，编译器会为该类⽣成⼀个虚函数表，保存该类中虚函数的地址，同样，派⽣类继承基类，派⽣类中⾃然⼀定有虚函数，所以编译器也会为派⽣类⽣成自己的虚函数表。当我们定义⼀个派⽣类对象时，编译器检测该类型有虚函数，所以为这个派⽣ 类对象⽣成⼀个虚函数指针，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数 中完成的。

后续如果有⼀个基类类型的指针，指向派⽣类，那么当调⽤虚函数时，就会根据所指真正对象的虚函数表指针去寻找虚函数的地址，也就可以调⽤派⽣类的虚函数表中的虚函数以此实现多态。
补充：如果基类中没有定义成 virtual，那么进⾏ Base B; Derived D; Base *p = D; p- >function(); 这种情况下调⽤的则是 Base 中的 function()。因为基类和派⽣类中都没有虚函数的定义，那么编译器就会认为不⽤留给动态多态的机会，就事先进⾏函数地址的绑定（早绑定），详述过程就是，定义了⼀个派⽣类对象，⾸先要构造基类的空间，然后构造派⽣类的自身内容，形成⼀个派⽣类对象，那么在进⾏类型转换时，直接截取基类的部分的内存，编译器 认为类型就是基类，那么（函数符号表［不同于虚函数表的另⼀个表］中）绑定的函数地址也就是基类中函数的地址，所以执行的是基类的函数。