#### 常⻅的IO模型，五种？异步IO应⽤场景？有什么缺点？

1) 同步


就是在发出⼀个功能调⽤时，在没有得到结果之前，该调⽤就不返回。  也就是必须⼀件⼀件 事做,等前⼀件做完了才能做下⼀件事。就是我调⽤⼀个功能，该功能没有结束前，我死等结 果。

2) 异步

当⼀个异步过程调⽤发出后，调⽤者不能⽴刻得到结果。实际处理这个调⽤的部件在完成后，  通过状态、通知和回调来通知调⽤者。就是我调⽤⼀个功能，不需要知道该功能结果，该功能 有结果后通知我（回调通知）

3) 阻塞

阻塞调⽤是指调⽤结果返回之前，当前线程会被挂起（线程进⼊⾮可执⾏状态，在这个状态下，  cpu不会给线程分配时间⽚，即线程暂停运⾏）。函数只有在得到结果之后才会返回。对 于同步调⽤来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回⽽已。就是调⽤我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。

4) ⾮阻塞

指在不能⽴刻得到结果之前，该函数不会阻塞当前线程，⽽会⽴刻返回。就是调⽤我（函 数），我（函数）⽴即返回，通过select通知调⽤者。

1) 阻塞I/O

应⽤程序调⽤⼀个IO函数，导致应⽤程序阻塞，等待数据准备好。 如果数据没有准备好，⼀ 直等待….数据准备好了，从内核拷⻉到⽤户空间,IO函数返回成功指示。

2) ⾮阻塞I/O

我们把⼀个SOCKET接⼝设置为⾮阻塞就是告诉内核，当所请求的I/O操作⽆法完成时，不要    将进程睡眠，⽽是返回⼀个错误。这样我们的I/O操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为⃞。在这个不断测试的过程中，会⃞⃞的 占⽤CPU的时间。

3) I/O复⽤


I/O复⽤模型会⽤到select、 poll、 epoll函数，这⼏个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这三个函数可以同时阻塞多个I/O操作。⽽且可以同时对多个读操作，多个写操作 的I/O函数进⾏检测，直到有数据可读或可写时，才真正调⽤I/O操作函数。

4) 信号驱动I/O

⾸先我们允许套接⼝进⾏信号驱动I/O,并安装⼀个信号处理函数，进程继续运⾏并不阻塞。当 数据准备好时，进程会收到⼀个SIGIO信号，可以在信号处理函数中调⽤I/O操作函数处理数据。

5) 异步I/O

当⼀个异步过程调⽤发出后，调⽤者不能⽴刻得到结果。实际处理这个调⽤的部件在完成后， 通过状态、通知和回调来通知调⽤者的输⼊输出操作。