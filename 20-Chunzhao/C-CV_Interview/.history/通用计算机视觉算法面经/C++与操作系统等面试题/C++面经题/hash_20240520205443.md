# hash
hash是一种高效搜索的数据结构
> 数据结构有: 数组、链表、栈、队列、树、图、堆、哈希表等
## 常见哈希函数
- 直接寻址法: 用关键字的某个线性函数值作为存储地址
- 除留余数法: 取关键字k被m除后所得的余数p为散列地址
- 平方取中法: 取关键字平方后的中间几位作为散列地址
- 折叠法: 将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址

## 哈希冲突

1. 开放定址法/闭散列
    - 线性探测法: 逐个探测下一个空位
        缺陷: 冲突成片, 产生数据堆积
    - 二次探测法：每次平方探测
        缺陷: 二次探测可能会产生循环, 空位较少需要查找多次
2. 链地址法/开散列
    - 将冲突的关键字链在一起: 每一个子集合称为桶, 各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中。
    - 优点: 冲突不会产生堆积, 查找速度快
    - 缺点: 需要额外的空间存储指针
    - 扩容: 当链表长度超过某个阈值时，需要对哈希表进行扩容，以减少冲突概率. 随着哈希桶中元素的增加, 链表的长度又会增加, 但还没有达到扩容阈值的时候: 将链表转为红黑树, 以减少查找时间.具体来说:
        - 未达到转换阈值: 仍然用链表存储,
        - 达到转换阈值, 但没达到扩容阈值: 将链表转为红黑树
        - 达到扩容阈值: 扩容, 重新计算哈希值, 重新分配

# C++相关容器

map相对于set的区别：
map所有元素





## map

- map
  - 头文件: #include <map>
  - 底层实现的数据结构: **红黑树**(插入和查询速度接近于O(logn), 内部元素是有序的)
  > 红黑树能够实现自动排序
  - 缺点: 占用空间: 每个节电需要保存父节点位置, 孩子
  - 存储效率: 接近100%
  - 查找稳定性: map的查找类似于平衡二叉树的查找，其性能十分稳定

- unordered_map: 
  - 头文件: #include <unordered_map>
  - 底层实现的数据结构: **哈希表**(插入和查询速度接近于O(1), 但是内部元素是无序的)
  - 存储效率: 会存在部分空间浪费
  - 查找稳定性: 依赖于散列表，如果哈希函数映射的关键码出现的冲突过多，则最坏时间复杂度可以达到是O(n)。因此unordered_map的查找次数是与存储数据的分布与大小有密切关系的，它的效率是不稳定的。

- multimap
  - multimap允许相同的key存在
  - 底层实现: 红黑树(元素自动排序)

## set
- unordered_set
  - 底层实现的数据结构: 哈希表
- set
  - 底层实现的数据结构: 红黑树

- 使用场景
  - 需要顺序存储, 