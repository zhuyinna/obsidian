- [2024-05-13 994 腐烂的橘子](#2024-05-13-994-腐烂的橘子)
- [2024-05-14 2244. 完成所有任务需要的最少轮数](#2024-05-14-2244-完成所有任务需要的最少轮数)
- [2024-05-15 2589. 完成所有任务的最少时间](#2024-05-15-2589-完成所有任务的最少时间)


# 2024-05-13 994 腐烂的橘子
> 广搜

dis[i][j]表示搜索到时所需最短路径(也即时间)

① 什么情况下跳过, 不执行操作? ( 以下均为或者 )
- 坐标不在合法区域内
- 未访问过: 判断dis[i][j]为-1(`~dis[i][j]`)
- 为空格无橘子: `grid[i][j]==0`

② 怎么判断是否所有橘子都被腐烂?
cnt记录新鲜橘子数, 每腐烂一个, cnt-1; 如果最后cnt=0, 说明腐烂完, cnt>0, 说明有橘子未被腐烂到.

```C++
void bfs(grid) {
    queue<pair<int, int>> Q;
    // 1. 初始化dis和cnt
    for(逐行)
        for(逐列遍历grid)
        if ( grid[i][j] == 2 ) {
            dis[i][j] = 0;
            Q.emplace(i,j);
        } else if ( grid[i][j] == 1 ) {
            cnt += 1;
        }
    while ( !Q.empty() ) {
        auto [r,c] = Q.front();
        Q.pop();
        // 遍历四个方向
            if ( 不在合法区域内 || ~dis[next_x][next_y] || grid[next_x][next_y]==0) {
                continue;
            }
            if ( grid[next_x][next_y] == 1 ) {
                cnt--;
                dis[next][next] = dis[x][y] + 1;
                ans = dis[next][next];
                if ( cnt==0 ) {
                    // trick: 提前结束遍历
                    break;
                }
            }
    }        
    return cnt==0 ? ans : -1;
}

int orangesRotting(vector<vector<int>>& grid) {
    return bfs(grid);
}
```

# 2024-05-14 2244. 完成所有任务需要的最少轮数
链接: 

```cpp
class Solution {
private:
    int getTime( int& num ) {
        for ( int i=num/3; i>=0;i-- ) {
            int res = num - i * 3;
            if ( res % 2 == 0 ) {
                return i + res / 2;
            }
        }
        return -1;
    }

public:
    int minimumRounds(vector<int>& tasks) {
        map<int,int> mp;
        for ( auto& t : tasks ) {
            if ( mp.find(t)==mp.end() ) {
                mp[t] = 1;
            } else {
                mp[t]++;
            }
        }
        int ans = 0;
        for ( auto [_,v] : mp ) {
            int time = getTime(v);
            if ( ~time ) {
                // time != -1
                ans += time;
            } else {
                return -1;
            }
        }
        return ans;
    }

};
```

**改进**
getTime优化: 除了1以外, 任何数字都能由2和3组成
```cpp
private:
    int getTime( int& num ) {
        if ( num==1 ) return -1;
        return num / 3 + (num % 3) / 2;
    }
```


# 2024-05-15 2589. 完成所有任务的最少时间

