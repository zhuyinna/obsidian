
# 哈希表
哈希法解决问题，有三种数据结构：
- 数组
- set
- map

set：

| 数据结构          | 底层实现 | 能否重复 | key值修改 | 是否有序 | 查询效率    | 增删效率    |
| ------------- | ---- | ---- | ------ | ---- | ------- | ------- |
| set           | 红黑树  | 不能   | 不能     | 是    | O(logn) | O(logn) |
| multiset      | 红黑树  | 能    | 不能     | 是    | O(logn) | O(logn) |
| unordered_set | 哈希表  | 不能   | 不能     | 否    | O(1)    | O(1)    |
map:

| 数据结构          | 底层实现 | 能否重复 | key值修改 | 是否有序 | 查询效率    | 增删效率    |
| ------------- | ---- | ---- | ------ | ---- | ------- | ------- |
| map           | 红黑树  | 不能   | 不能     | 是    | O(logn) | O(logn) |
| multimap      | 红黑树  | 能    | 不能     | 是    | O(logn) | O(logn) |
| unordered_map | 哈希表  | 不能   | 不能     | 否    | O(1)    | O(1)    |

## 创建容器
1. set
声明：
`unordered_set<int> set1,set2;`
插入：
`set1.insert(num);`
检查是否存在key
`set2.count(num)` 返回1或者0

2. map
声明
`unordered_map<char,int> table;`
统计key的次数
`table[char]++;`
遍历map中的数值对
`for ( auto& kv:table ) { if (kv.second!=0) ...}`


# 回溯法
回溯法解决了如下问题：[组合问题 (opens new window)](https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)，[分割问题 (opens new window)](https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html)，[子集问题 (opens new window)](https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)，[排列问题 (opens new window)](https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html)。


# 动态规划
## 总结
1. 组合or排列
   - 组合：无关顺序——外层遍历物品，内层遍历背包（比较常见） 
   - 排列：顺序有关——外层遍历背包，内层遍历物品
2. 01背包or完全背包
   - 01：物品只能取一次——背包由后向前遍历
   - 完全：可以重复取——背包由前向后遍历

## 题目
1. 爬楼梯
排列+完全
```cpp

for ( )
```


