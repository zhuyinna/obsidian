
# 哈希表
哈希法解决问题，有三种数据结构：
- 数组
- set
- map

set：

| 数据结构          | 底层实现 | 能否重复 | key值修改 | 是否有序 | 查询效率    | 增删效率    |
| ------------- | ---- | ---- | ------ | ---- | ------- | ------- |
| set           | 红黑树  | 不能   | 不能     | 是    | O(logn) | O(logn) |
| multiset      | 红黑树  | 能    | 不能     | 是    | O(logn) | O(logn) |
| unordered_set | 哈希表  | 不能   | 不能     | 否    | O(1)    | O(1)    |
map:

| 数据结构          | 底层实现 | 能否重复 | key值修改 | 是否有序 | 查询效率    | 增删效率    |
| ------------- | ---- | ---- | ------ | ---- | ------- | ------- |
| map           | 红黑树  | 不能   | 不能     | 是    | O(logn) | O(logn) |
| multimap      | 红黑树  | 能    | 不能     | 是    | O(logn) | O(logn) |
| unordered_map | 哈希表  | 不能   | 不能     | 否    | O(1)    | O(1)    |

## 创建容器
1. set
声明：
`unordered_set<int> set1,set2;`
插入：
`set1.insert(num);`
检查是否存在key
`set2.count(num)` 返回1或者0

2. map
声明
`unordered_map<char,int> table;`
统计key的次数
`table[char]++;`
遍历map中的数值对
`for ( auto& kv:table ) { if (kv.second!=0) ...}`


# 回溯法
回溯法解决了如下问题：[组合问题 (opens new window)](https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)，[分割问题 (opens new window)](https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html)，[子集问题 (opens new window)](https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)，[排列问题 (opens new window)](https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html)。


# 动态规划
## 总结
1. 组合or排列
   - 组合：无关顺序——外层遍历物品，内层遍历背包（比较常见） 
   - 排列：顺序有关——外层遍历背包，内层遍历物品
2. 01背包or完全背包
   - 01：物品只能取一次——背包由后向前遍历
   - 完全：可以重复取——背包由前向后遍历

## TODO
如果子数组要求是连续的？

## 题目

1. 爬楼梯
排列+完全
```cpp
// 外层遍历背包：即楼梯
// 内层遍历可爬楼梯数：即[0,1]
// 遍历背包：由前向后
vector<int> steps = {1,2};
vector<int> dp(n+1,0);
dp[0] = 1; // 注意初始化
for ( int j=1; j<=n; j++ ) {
	for ( int i=0; i<steps.size(); i++ )
```

2. 打家劫舍
dp[i]： [0...i] 能偷到的最大金额
i偷: dp[i-2]+nums[i]
i不偷: dp[i-1]
dp[i] 取max
```cpp
//只需一层遍历，从前向后
dp[0] = nums[0];
dp[1] = max(nums[0], nums[1]);
for ( int i=2; i<nums.size(); i++ ) {
	dp[i] = max( dp[i-2]+nums[i], dp[i-1] );
}
```

3. 完全平方数
[279. 完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&envId=top-100-liked)
组合+完全背包

```cpp
// 组合：外层遍历物品：数
// 完全：背包从前向后遍历
for ( int i=1; i<=T; i++ ) {  // T是提前计算出的最大开方
	for ( int j=i*i; j<=n; j++ ) {
		dp[j] = min(dp[j], dp[j-i*i]+1);  // 用到i*i，和不用到
	}
}
```

4. 零钱兑换
- 第一种：可以凑成总金额的最少硬币数：能够重复使用
[322. 零钱兑换 - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&envId=top-100-liked)
```cpp
// 组合：外层遍历物品：硬币
// 完全：背包从前向后
for ( int i=0; i<coins.size(); i++ ) {
	for ( int j=coins[i]; j<=amount; j++ ) {
		dp[j] = min( dp[j], dp[j-coins[i]]+1);
	}
}
```

5. 单词拆分
*回溯法会超时，只能用动规*
dp size = N+1
dp[0] = 0
i：[1..N]
	j： [0..i-1] 
		如果dp[j]=true 且 [j+1, i]在dict里，则为true
```cpp
for ( int i=1; i<=s.size(); i++ ) {
	for ( int j=0; j<i; j++ ) {
		if ( dp[j] && 
			wordDictSet.find(s.substr(j,i-j))!=wordDictSet.end() ){
			// 注意这里substr是从j开始
			// 因为根据推导dp数组的j是比原数组的索引大1的，所以要减去1
			dp[i]=true;
			break;
	}
}
```

6. 最长递增子序列
[300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-100-liked)
不要求连续
dp[i] : 往前找，每找到一个比自己（严格）小的，
dp[i] = max(dp[i], dp[j]+1);
```cpp
for ( int i=1; i<nums.size(); i++ ){
	for ( int j=0; j<i; j++ ) {
		if (nums[j]<nums[i]) {
			dp[i] = max( dp[i], dp[j]+1 );
		}
	}
	res = max(res, dp[i]);  // 每一个i都要更新最终res值
```

7. 分割等和子集
[416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/description/?envType=study-plan-v2&envId=top-100-liked)
可以转换为：是否含有（可以不连续）的子数组，组成的和=sum/2
```cpp
// 组合 + 01
// 01: 需要从后向前遍历背包
for ( int i=0; i<nums.size(); i++ ) {
	for ( int j=target; j>=nums[i]; j-- ) {
		dp[j] = ( dp[j-nums[i]] || dp[j]  );
	}
}
```

8. 最长有效括号
[32. 最长有效括号 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)
dp[i] ： 以s[i] 为结尾的最长有效括号数
	s[i] = ‘(’      dp[i]=0
	s[i] = ')'     再去看前一个为'(' 还是 ')'
```cpp 
// 关键代码
for (int i = 1; i < s.size(); i++) {
	if ( s[i]==')' ){
		if (s[i-1]=='(') {
			dp[i] = (i>=2? dp[i-2]:0)+2;
		} else {
			if ( i-dp[i-1]>0 && s[i-dp[i-1]-1]=='(' ) {
				dp[i] = dp[i-1] + 2 + ((i-dp[i-1]-2>=0)?dp[i-dp[i-1]-2]:0);
			}
		}
		res = max(res, dp[i]);
	}
}
```

