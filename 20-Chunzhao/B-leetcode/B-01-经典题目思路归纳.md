
# 哈希表
哈希法解决问题，有三种数据结构：
- 数组
- set
- map

set：

| 数据结构          | 底层实现 | 能否重复 | key值修改 | 是否有序 | 查询效率    | 增删效率    |
| ------------- | ---- | ---- | ------ | ---- | ------- | ------- |
| set           | 红黑树  | 不能   | 不能     | 是    | O(logn) | O(logn) |
| multiset      | 红黑树  | 能    | 不能     | 是    | O(logn) | O(logn) |
| unordered_set | 哈希表  | 不能   | 不能     | 否    | O(1)    | O(1)    |
map:

| 数据结构          | 底层实现 | 能否重复 | key值修改 | 是否有序 | 查询效率    | 增删效率    |
| ------------- | ---- | ---- | ------ | ---- | ------- | ------- |
| map           | 红黑树  | 不能   | 不能     | 是    | O(logn) | O(logn) |
| multimap      | 红黑树  | 能    | 不能     | 是    | O(logn) | O(logn) |
| unordered_map | 哈希表  | 不能   | 不能     | 否    | O(1)    | O(1)    |

## 创建容器
1. set
声明：
`unordered_set<int> set1,set2;`
插入：
`set1.insert(num);`
检查是否存在key
`set2.count(num)` 返回1或者0

2. map
声明
`unordered_map<char,int> table;`
统计key的次数
`table[char]++;`
遍历map中的数值对
`for ( auto& kv:table ) { if (kv.second!=0) ...}`

# 数组

## 题型

### 寻找第k大的数
【建立小根堆（因为需要根节点以外的都比根节点小，这样才可以直接取出根节点）->遍历，如果比root小，continue；如果比root大，替换root】
【关键：小根堆的lambda比较函数】
【优先级队列】
这里que(cmp)需要传cmp函数：因为lambda这种特殊的class没有默认构造函数，而优先级队列内部排序时需要使用一个实例化的lambda对象，只能通过lambda的copy构造进行实例化。从哪里copy呢，就需要priority_queue构造函数的时候传入这个lambda对象。
```cpp
#include<queue>
auto cmp = [](int a, int b) { return a<b;} 
// 如何记忆？ 堆排序的cmp函数是和一般的数组相反的，堆排序中：a<b true 则b先进入，并沉底，所以小的a后进并靠上，也就是小根堆
priority_queue<int, vector<int>, decltype(cmp)> que(cmp);
```

# 回溯法

## 总结

回溯法解决了如下问题：[组合问题 (opens new window)](https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)，[分割问题 (opens new window)](https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html)，[子集问题 (opens new window)](https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)，[排列问题 (opens new window)](https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html)。

- 组合问题：N个数里面按一定规则找出k个数的集合
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 棋盘问题：N皇后，解数独等等
 
**回溯三部曲**
1. 递归函数的返回值以及参数
   startIndex：是否有重复值？
2. 回溯终止条件
3. 单层搜索过程
技巧
1. 是否需要startIndex？
   - 单个集合求组合，需要
   - 如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex：例如[17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)
2. startIndex是否要+1？——原组合无重复!!!
   - 元素可以重复取：不用+1
   - 不可以重复取：必须+1
```cpp
// 可以重复取
for ( int i=startIndex; i<candidates.size(); i++ ) {
	path.push_back(candidates[i]);
	backtrack(candidates, target-candidates[i], i);
	path.pop_back();
}
```
3. 原数组有重复，每层搜索需要去重
- 纵向是否使用？：used数组加入参数，在每层搜索中，backtrack前后进行置1和置0
- 横向是否使用？：需要对原数组进行排序!!! 

```cpp
void backtracking(vector<int>& candidates, int target, int sum, int startIndex, vector<bool>& used)
 for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
	// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
	// used[i - 1] == false，说明同一树层candidates[i - 1]使用过
	// 要对同一树层使用过的元素进行跳过
	if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {
		continue;
	}
```
## 组合问题

**题型**
- 取数组中的某几个，满足什么什么条件？ 
[77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/description/)：给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合
[216. 组合总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iii/description/)：找出所有相加之和为 n 的 k 个数的组合
[39. 组合总和 - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum/description/)：无重复数组，找出子数组使得和为target， 可以重复取

## 分割问题

**题型**
- [131. 分割回文串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-partitioning/description/)：分割成子串，均为回文串

### 分割子串
- 终止条件：分割线为startIndex：如果startIndex为size，找到一组，加入result
- 单层搜索：从startIndex到 i 是否回文，不是则continue ； 是：backtrack，并从i+1作为下一个startIndex

# 动态规划
## 总结
1. 组合or排列
   - 组合：无关顺序——外层遍历物品，内层遍历背包（比较常见） 
   - 排列：顺序有关——外层遍历背包，内层遍历物品
2. 01背包or完全背包
   - 01：物品只能取一次——背包由后向前遍历
   - 完全：可以重复取——背包由前向后遍历

## 题型

### 爬楼梯
排列+完全
```cpp
// 外层遍历背包：即楼梯
// 内层遍历可爬楼梯数：即[0,1]
// 遍历背包：由前向后
vector<int> steps = {1,2};
vector<int> dp(n+1,0);
dp[0] = 1; // 注意初始化
for ( int j=1; j<=n; j++ ) {
	for ( int i=0; i<steps.size(); i++ )
```

### 打家劫舍
1. 普通
dp[i]： [0...i] 能偷到的最大金额
i偷: dp[i-2]+nums[i]
i不偷: dp[i-1]
dp[i] 取max
```cpp
//只需一层遍历，从前向后
dp[0] = nums[0];
dp[1] = max(nums[0], nums[1]);
for ( int i=2; i<nums.size(); i++ ) {
	dp[i] = max( dp[i-2]+nums[i], dp[i-1] );
}
```

2. 首尾相连

### 完全平方数
[279. 完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&envId=top-100-liked)
组合+完全背包

```cpp
// 组合：外层遍历物品：数
// 完全：背包从前向后遍历
for ( int i=1; i<=T; i++ ) {  // T是提前计算出的最大开方
	for ( int j=i*i; j<=n; j++ ) {
		dp[j] = min(dp[j], dp[j-i*i]+1);  // 用到i*i，和不用到
	}
}
```

### 零钱兑换
1. 可以凑成总金额的最少硬币数：能够重复使用
[322. 零钱兑换 - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&envId=top-100-liked)
```cpp
// 组合：外层遍历物品：硬币
// 完全：背包从前向后
for ( int i=0; i<coins.size(); i++ ) {
	for ( int j=coins[i]; j<=amount; j++ ) {
		dp[j] = min( dp[j], dp[j-coins[i]]+1);
	}
}
```

### 单词拆分
*回溯法会超时，只能用动规*
dp size = N+1
dp[0] = 0
i：[1..N]
	j： [0..i-1] 
		如果dp[j]=true 且 [j+1, i]在dict里，则为true
```cpp
for ( int i=1; i<=s.size(); i++ ) {
	for ( int j=0; j<i; j++ ) {
		if ( dp[j] && 
			wordDictSet.find(s.substr(j,i-j))!=wordDictSet.end() ){
			// 注意这里substr是从j开始
			// 因为根据推导dp数组的j是比原数组的索引大1的，所以要减去1
			dp[i]=true;
			break;
	}
}
```

### 最长递增子序列
1. 不要求连续
[300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-100-liked)
dp[i] : 往前找，每找到一个比自己（严格）小的，
dp[i] = max(dp[i], dp[j]+1);
```cpp
for ( int i=1; i<nums.size(); i++ ){
	for ( int j=0; j<i; j++ ) {
		if (nums[j]<nums[i]) {
			dp[i] = max( dp[i], dp[j]+1 );
		}
	}
	res = max(res, dp[i]);  // 每一个i都要更新最终res值
```
2. 要求连续
dp[i] : 如果比前一个严格大，那么dp[i-1]+1， 如果小于等于前一个，那么=1
### 分割等和子集
[416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/description/?envType=study-plan-v2&envId=top-100-liked)
可以转换为：是否含有（可以不连续）的子数组，组成的和=sum/2
```cpp
// 组合 + 01
// 01: 需要从后向前遍历背包
for ( int i=0; i<nums.size(); i++ ) {
	for ( int j=target; j>=nums[i]; j-- ) {
		dp[j] = ( dp[j-nums[i]] || dp[j]  );
	}
}
```

### 最长有效括号
[32. 最长有效括号 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)
dp[i] ： 以s[i] 为结尾的最长有效括号数
	s[i] = ‘(’      dp[i]=0
	s[i] = ')'     再去看前一个为'(' 还是 ')'
```cpp 
// 关键代码
for (int i = 1; i < s.size(); i++) {
	if ( s[i]==')' ){
		if (s[i-1]=='(') {
			dp[i] = (i>=2? dp[i-2]:0)+2;
		} else {
			if ( i-dp[i-1]>0 && s[i-dp[i-1]-1]=='(' ) {
				dp[i] = dp[i-1] + 2 + ((i-dp[i-1]-2>=0)?dp[i-dp[i-1]-2]:0);
			}
		}
		res = max(res, dp[i]);
	}
}
```

### 股票

1. [121. 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)
   只交易一次：依次遍历，找最小值，相减，得到最大值
2. [122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)
   可以不止交易一次，但每次最多持有一股：动态规划
   `dp[n][2]`: 其中`dp[i][0]`表示买入股票，`dp[i][1]`表示卖出股票
   返回：`dp[size-1][1]`
3. [123. 买卖股票的最佳时机 III - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)
   最多完成两笔交易：动态规划
   `dp[n][5]`: 其中`dp[i][1]`表示第一次买入股票，`dp[i][2]`表示第一次卖出股票，`dp[i][3]`表示第二次买入股票，`dp[i][4]`表示第二次卖出股票
   
   *`注意：dp[i][0] 其实可以去掉，这样dp[i][1] = max( dp[i-1][1], dp[i-1][0] - prices[i] );`*
   
```cpp
int maxProfit(vector<int>& prices) {
	int N = prices.size();
	vector<vector<int>> dp(N, vector<int>(5,0));
	// 其中dp[i][0] 表示未进行过任何操作
	dp[0][1] = -prices[0];
	dp[0][3] = -prices[0]; // 在同一天卖出后，又一次买入
	for ( int i=1; i<N; i++ ) {
		dp[i][1] = max( dp[i-1][1], dp[i-1][0] - prices[i] );
		dp[i][2] = max( dp[i-1][2], dp[i-1][1] + prices[i] );
		dp[i][3] = max( dp[i-1][3], dp[i-1][2] - prices[i] );
		dp[i][4] = max( dp[i-1][4], dp[i-1][3] + prices[i] );
	}
	return dp[N-1][4];
}
```

4. [188. 买卖股票的最佳时机 IV - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)
   最多完成k笔交易：类似于最多完成2笔交易，只不过把`dp[n][5]`变成`dp[n][2*k+1]`

# 并查集

## 模板

```cpp
// 朴素并查集
int Find( vector<int>& parent, int x ) {
	if ( parent[x]!=x ) {
		parent[x] = Find(parent, parent[x]);
	}
	return parent[x];
}

void Merge( vector<int>& parent, int x, int y ) {
	parent[Find(parent, x)] = Find(parent, y);
	size[y] += size[x]; // 维护size的并查集	
}
```

# 二叉树
## 题型
- 基本：中序遍历，前序遍历，后续遍历


### 对称二叉树
递归：
- 参数：左节点，右节点
- 递归终止：（左右均为空）=true；（左右有一个为空 or 左右不相等）=false；
- 返回值：fun（左节点的左，右节点的右）&&fun（左节点的右，右节点的左）

### 遍历
1. 中序遍历
   【递归】
- 参数：节点，中序遍历的result数组
- 无返回值（因为直接传递引用，修改result数组）
- fun（左节点）-->将当前node->val加入result-->fun（右节点）

2. 前序遍历
3. 后序遍历

4. 层序遍历
   【队列：bfs】
   第一种方法：通过在每一层的结束push_back(nullptr)来标志结束
   第二种方法：求出每一层的节点数
```cpp
que.push(root);
while( !que.empty() ) {
	int size = que.size();
	for ( int i=0; i<size(); i++ ) {
		TreeNode* cur = que.front(); que.pop();
		ret.push_back(cur->val); // 记录到result数组
		if ( cur->left ) que.push(cur->left);
		if ( cur->right ) que.push(cur->right);
	}
}
```

### 二叉搜索树
*概念：每一个节点，左子树小于自己，右子树大于自己*
1. 已经排好序的整数数组->平衡二叉搜索树
   【递归】
2. 验证二叉搜索树
   【中序遍历：满足每一个数>=前一个数】
   【stack记录】
3. 二叉搜索树中第k小的元素
   【中序遍历：每pop一个数，k--，直到k=0】
   【stack记录】



```ad-note
title: 二叉搜索树和堆排序的区别？
在二叉排序树中，每个结点的值均大于其左子树上所有结点的值，小于其右子树上所有结点的值，对二叉排序树进行中序遍历得到一个有序序列。所以，二叉排序树是结点之间满足一定次序关系的二叉树；
堆是一个完全二叉树，并且每个结点的值都大于或等于其左右孩子结点的值（这里的讨论以大根堆为例），所以，堆是结点之间满足一定次序关系的完全二叉树。
```

### 路径总和

1. root->leave: 是否存在和=target，返回true / false
2. root->leave: 找出所有路径
3. 不一定root，也不一定leave：返回路径数目
   【用递归比较好，回溯很复杂】
   前序遍历节点，以当前节点作为起点，找出最大的路径
